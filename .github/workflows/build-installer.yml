name: Build Installer and ISO

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'scripts/install.sh'
      - 'backend/**'
      - 'frontend/**'
      - 'config/**'
      - 'live-build/**'
    tags:
      - 'v*'  # Trigger su tag versioni (es: v1.0.0)
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:  # Permette esecuzione manuale
    inputs:
      version:
        description: 'Version number (es: 1.0.0). Se vuoto, usa automatico.'
        required: false
        type: string

jobs:
  build-installer:
    runs-on: debian-12  # Usa Debian invece di Ubuntu per evitare conflitti con ubuntu-keyring
    permissions:
      contents: write  # Necessario per creare release e tag
      actions: read    # Necessario per leggere gli artifact
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history per tag/version detection
        
    - name: Determine version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.version }}" ]; then
          # Versione manuale da input
          VERSION="${{ inputs.version }}"
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Versione da tag (rimuovi 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
        elif [ -f VERSION ]; then
          # Leggi da file VERSION
          VERSION=$(cat VERSION)
          # Incrementa patch version per ogni build
          COMMITS=$(git rev-list --count HEAD)
          BASE_VERSION=$(echo $VERSION | cut -d. -f1-2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION="${BASE_VERSION}.$((PATCH + COMMITS))"
        else
          # Versione automatica basata su commit count
          COMMITS=$(git rev-list --count HEAD)
          VERSION="0.0.${COMMITS}"
        fi
        
        # Rimuovi eventuali caratteri non validi
        VERSION=$(echo "$VERSION" | sed 's/[^0-9.]//g')
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Versione determinata: $VERSION"
        
    - name: Update version files
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Aggiorna file VERSION
        echo "$VERSION" > VERSION
        
        # Aggiorna backend/main.py
        sed -i "s/version=\"[^\"]*\"/version=\"$VERSION\"/" backend/main.py
        
        # Aggiorna frontend/package.json
        sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" frontend/package.json
        
        echo "‚úÖ Versioni aggiornate a $VERSION"
        cat VERSION
      
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y makeself || echo "makeself non disponibile nel repo, verr√† scaricato"
        
    - name: Check makeself availability
      id: check_makeself
      run: |
        if command -v makeself.sh &> /dev/null 2>&1; then
          echo "available=true" >> $GITHUB_OUTPUT
          echo "‚úì makeself.sh trovato in PATH"
          makeself.sh --version 2>/dev/null || true
        else
          echo "available=false" >> $GITHUB_OUTPUT
          echo "‚ö† makeself.sh non in PATH, verr√† scaricato"
        fi
        
    - name: Build installer_dsm.sh
      run: |
        # Il repository √® gi√† nella root del workspace
        # Simula la struttura: makeself-2.5.0/ con nas/ come sibling
        # Ma in GitHub Actions, il repo √® gi√† nella root, quindi:
        
        cd "$GITHUB_WORKSPACE"
        
        # Installa o usa makeself
        if [ "${{ steps.check_makeself.outputs.available }}" = "true" ] && command -v makeself.sh &> /dev/null 2>&1; then
          MAKESELF_CMD="makeself.sh"
          echo "‚úì Usando makeself.sh dal sistema"
        else
          # Fallback: scarica makeself via git (pi√π affidabile del .run)
          echo "üì• Scaricamento makeself dal repository GitHub..."
          cd /tmp
          rm -rf makeself-repo 2>/dev/null || true
          
          # Prova a clonare il repository makeself
          if command -v git &> /dev/null 2>&1; then
            git clone --depth 1 https://github.com/megastep/makeself.git makeself-repo 2>&1 || {
              echo "‚ö† Clone git fallito, provo con file .run..."
            }
            
            if [ -f "/tmp/makeself-repo/makeself.sh" ]; then
              MAKESELF_CMD="/tmp/makeself-repo/makeself.sh"
              chmod +x "$MAKESELF_CMD"
              cd "$GITHUB_WORKSPACE"
              echo "‚úì makeself trovato via git: $MAKESELF_CMD"
            fi
          fi
          
          # Se git non ha funzionato, usa il file .run
          if [ -z "$MAKESELF_CMD" ] || [ ! -f "$MAKESELF_CMD" ]; then
            echo "üì• Scaricamento makeself 2.5.0.run..."
            cd "$GITHUB_WORKSPACE"
            wget -q https://github.com/megastep/makeself/releases/download/release-2.5.0/makeself-2.5.0.run || {
              echo "‚ùå Errore nel download di makeself"
              exit 1
            }
            chmod +x makeself-2.5.0.run
            
            # Estrai makeself in directory temporanea
            EXTRACT_DIR="/tmp/makeself-extract"
            rm -rf "$EXTRACT_DIR" 2>/dev/null || true
            mkdir -p "$EXTRACT_DIR"
            cd "$EXTRACT_DIR"
            
            # Estrai il file (senza --target per estrarre nella directory corrente)
            bash "$GITHUB_WORKSPACE/makeself-2.5.0.run" --nox11 --quiet 2>&1 || {
              echo "‚ö† Estrazione senza target fallita, provo con --target..."
              bash "$GITHUB_WORKSPACE/makeself-2.5.0.run" --nox11 --quiet --target "$EXTRACT_DIR" 2>&1 || {
                echo "‚ùå Errore nell'estrazione di makeself"
                exit 1
              }
            }
            
            # Cerca makeself.sh - potrebbe essere in diverse posizioni
            MAKESELF_SCRIPT=""
            for possible_path in \
              "$EXTRACT_DIR/makeself-2.5.0/makeself.sh" \
              "$EXTRACT_DIR/makeself.sh" \
              "./makeself.sh" \
              "$(find "$EXTRACT_DIR" -name "makeself.sh" -type f 2>/dev/null | head -1)" \
              "$(find . -maxdepth 3 -name "makeself.sh" -type f 2>/dev/null | head -1)"; do
              if [ -n "$possible_path" ] && [ -f "$possible_path" ]; then
                MAKESELF_SCRIPT="$(cd "$(dirname "$possible_path")" && pwd)/$(basename "$possible_path")"
                [ -f "$MAKESELF_SCRIPT" ] && break || MAKESELF_SCRIPT=""
              fi
            done
            
            if [ -z "$MAKESELF_SCRIPT" ] || [ ! -f "$MAKESELF_SCRIPT" ]; then
              echo "‚ùå makeself.sh non trovato dopo l'estrazione"
              echo "Contenuto directory di estrazione ($EXTRACT_DIR):"
              ls -la "$EXTRACT_DIR" 2>/dev/null || true
              echo "Contenuto directory corrente:"
              ls -la . 2>/dev/null || true
              echo "Cerca tutti i file .sh:"
              find "$EXTRACT_DIR" -name "*.sh" -type f 2>/dev/null | head -10 || true
              find . -maxdepth 3 -name "*.sh" -type f 2>/dev/null | head -10 || true
              exit 1
            fi
            
            chmod +x "$MAKESELF_SCRIPT"
            MAKESELF_CMD="$MAKESELF_SCRIPT"
            cd "$GITHUB_WORKSPACE"
            echo "‚úì makeself trovato: $MAKESELF_CMD"
          fi
        fi
        
        # Leggi versione
        VERSION="${{ steps.version.outputs.version }}"
        INSTALLER_NAME="installer_dsm_v${VERSION}.sh"
        
        # Assicurati che tutti gli script siano eseguibili prima di creare l'archivio
        echo "Impostazione permessi di esecuzione per gli script..."
        find scripts/ -type f -name "*.sh" -exec chmod +x {} \;
        find backend/scripts/ -type f -name "*.py" -exec chmod +x {} \; 2>/dev/null || true
        chmod +x scripts/install.sh || true
        
        # Verifica che install.sh sia eseguibile
        if [ ! -x "scripts/install.sh" ]; then
          echo "‚ùå ERRORE: scripts/install.sh non √® eseguibile!"
          ls -la scripts/install.sh
          chmod +x scripts/install.sh
        fi
        
        echo "‚úì Permessi impostati"
        
        # Esegui makeself come nel tuo comando:
        # ./makeself.sh ../nas/ installer_dsm.sh VirtualDSM ./scripts/install.sh
        # Ma in GitHub Actions, il repo √® gi√† nella root, quindi usiamo ./
        echo "Esecuzione makeself per versione $VERSION..."
        $MAKESELF_CMD ./ "$INSTALLER_NAME" "VirtualDSM v${VERSION}" ./scripts/install.sh
        
        # Sposta il file risultante in scripts/
        if [ -f "$INSTALLER_NAME" ]; then
          mv "$INSTALLER_NAME" scripts/
          # Crea anche un symlink/alias senza versione per compatibilit√†
          cp "scripts/$INSTALLER_NAME" "scripts/installer_dsm.sh"
          echo "‚úì $INSTALLER_NAME creato in scripts/"
          echo "‚úì installer_dsm.sh (alias) creato in scripts/"
        else
          echo "‚úó ERRORE: $INSTALLER_NAME non creato!"
          exit 1
        fi
        
    - name: Verify installer file
      run: |
        if [ ! -f "scripts/installer_dsm.sh" ]; then
          echo "ERRORE: installer_dsm.sh non trovato!"
          exit 1
        fi
        
        # Verifica che sia un file makeself valido
        file scripts/installer_dsm.sh
        ls -lh scripts/installer_dsm.sh
        
        # Verifica che sia eseguibile
        chmod +x scripts/installer_dsm.sh
        
    - name: Test extraction (dry run)
      run: |
        # Test estrazione senza eseguire
        mkdir -p /tmp/test_extract
        cd /tmp/test_extract
        bash "$GITHUB_WORKSPACE/scripts/installer_dsm.sh" --help || bash "$GITHUB_WORKSPACE/scripts/installer_dsm.sh" --check || echo "File makeself valido"
        rm -rf /tmp/test_extract
        
    - name: Upload installer as artifact
      uses: actions/upload-artifact@v4
      with:
        name: installer-dsm-v${{ steps.version.outputs.version }}
        path: |
          scripts/installer_dsm_v${{ steps.version.outputs.version }}.sh
          scripts/installer_dsm.sh
        retention-days: 90
        
    - name: Build ISO
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        echo "üî® Preparazione build ISO..."
        
        # Installa dipendenze per live-build
        sudo apt-get update
        sudo apt-get install -y live-build live-boot live-config debian-keyring debootstrap make grub-pc-bin grub-efi-amd64-bin dosfstools mtools syslinux isolinux
        
        # Assicurati che installer_dsm.sh sia nella posizione corretta per build.sh
        # build.sh si aspetta ../scripts/installer_dsm.sh (rispetto a live-build/)
        if [ ! -f "scripts/installer_dsm.sh" ]; then
          echo "üìã Copio installer generato nella posizione corretta..."
          cp "scripts/installer_dsm_v${VERSION}.sh" "scripts/installer_dsm.sh" || {
            echo "‚ùå Errore: impossibile copiare installer"
            exit 1
          }
          echo "‚úì installer_dsm.sh copiato da installer_dsm_v${VERSION}.sh"
        fi
        
        # Verifica che installer_dsm.sh sia un file makeself valido
        if file "scripts/installer_dsm.sh" | grep -q "Makeself"; then
          echo "‚úì installer_dsm.sh verificato (makeself)"
        else
          echo "‚ö†Ô∏è installer_dsm.sh potrebbe non essere un file makeself valido"
          file "scripts/installer_dsm.sh" || true
        fi
        
        # Vai nella directory live-build
        cd live-build
        
        # Esegui build.sh (deve essere eseguito come root)
        echo "üöÄ Avvio build ISO (questo richieder√† 30-60 minuti)..."
        echo "‚ö†Ô∏è Assicurati di avere almeno 15GB di spazio disponibile"
        
        # Esegui build.sh salvando i log
        # build.sh gi√† usa | tee -a build.log per salvare i log
        echo "üìã I log della build verranno salvati in live-build/build.log"
        sudo bash build.sh 2>&1 | tee iso-build.log || {
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          echo "‚ùå Build ISO fallita con codice: $BUILD_EXIT_CODE"
          echo "=== Ultime 100 righe del log ==="
          tail -100 iso-build.log || true
          if [ -f "build.log" ]; then
            echo "=== Ultime 100 righe di build.log ==="
            tail -100 build.log || true
          fi
          exit $BUILD_EXIT_CODE
        }
        
        echo "‚úÖ Build ISO completata"
        
        # Mostra i log recenti
        if [ -f "build.log" ]; then
          echo "=== Ultime 50 righe del log di build ==="
          tail -50 build.log || true
        fi
        
        # Verifica che l'ISO sia stata creata
        ISO_FILE=""
        for iso in binary-hybrid.iso binary.iso *.iso; do
          if [ -f "$iso" ]; then
            ISO_FILE="$iso"
            break
          fi
        done
        
        if [ -z "$ISO_FILE" ]; then
          echo "‚ö†Ô∏è ISO non trovata nella directory corrente"
          echo "Cerca ISO in tutte le directory:"
          find . -name "*.iso" -type f 2>/dev/null | head -5 || true
          echo "=== Contenuto directory live-build ==="
          ls -lah . | head -20 || true
        else
          ISO_SIZE=$(du -h "$ISO_FILE" | cut -f1)
          echo "‚úÖ ISO creata con successo!"
          echo "   File: $ISO_FILE"
          echo "   Dimensione: $ISO_SIZE"
          ls -lh "$ISO_FILE"
        fi
        
    - name: Upload ISO as artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: iso-v${{ steps.version.outputs.version }}
        path: |
          live-build/binary-hybrid.iso
          live-build/binary.iso
          live-build/*.iso
        if-no-files-found: warn
        retention-days: 90
        
    - name: Upload ISO build logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: iso-build-logs-v${{ steps.version.outputs.version }}
        path: |
          live-build/iso-build.log
          live-build/build.log
        if-no-files-found: ignore
        retention-days: 30
        
    - name: Create GitHub Release with ISO
      if: startsWith(github.ref, 'refs/tags/v') && success()
      uses: softprops/action-gh-release@v1
      with:
        files: |
          scripts/installer_dsm_v${{ steps.version.outputs.version }}.sh
          live-build/binary-hybrid.iso
          live-build/binary.iso
          live-build/*.iso
        name: Release v${{ steps.version.outputs.version }}
        body: |
          ## VirtualDSM Installer v${{ steps.version.outputs.version }}
          
          ### Download
          - **installer_dsm_v${{ steps.version.outputs.version }}.sh** - Installer completo
          - **ISO Image** - Immagine ISO Debian Live con auto-installer
          
          ### Installazione
          
          #### Opzione 1: Usa l'installer diretto
          ```bash
          chmod +x installer_dsm_v${{ steps.version.outputs.version }}.sh
          sudo ./installer_dsm_v${{ steps.version.outputs.version }}.sh
          ```
          
          #### Opzione 2: Usa l'ISO
          1. Scrivi l'ISO su USB: `sudo dd if=*.iso of=/dev/sdX bs=4M status=progress`
          2. Boot da USB
          3. L'installer si avvier√† automaticamente al primo boot
          
          ### Build Info
          - **Versione:** ${{ steps.version.outputs.version }}
          - **Commit:** ${{ github.sha }}
          - **Data:** ${{ github.event.head_commit.timestamp }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Summary
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        echo "## üì¶ Build Completato" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Versione:** \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üì• Artifacts Disponibili:" >> $GITHUB_STEP_SUMMARY
        echo "- \`installer-dsm-v${VERSION}\` - Installer makeself" >> $GITHUB_STEP_SUMMARY
        echo "- \`iso-v${VERSION}\` - Immagine ISO Debian Live" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìã File:" >> $GITHUB_STEP_SUMMARY
        echo "- \`installer_dsm_v${VERSION}.sh\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`installer_dsm.sh\` (alias)" >> $GITHUB_STEP_SUMMARY
        echo "- \`*.iso\` (Immagine ISO)" >> $GITHUB_STEP_SUMMARY

