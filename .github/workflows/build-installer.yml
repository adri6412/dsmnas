name: Build Installer with Makeself

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'scripts/install.sh'
      - 'backend/**'
      - 'frontend/**'
      - 'config/**'
    tags:
      - 'v*'  # Trigger su tag versioni (es: v1.0.0)
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:  # Permette esecuzione manuale
    inputs:
      version:
        description: 'Version number (es: 1.0.0). Se vuoto, usa automatico.'
        required: false
        type: string

jobs:
  build-installer:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Necessario per creare release e tag
      actions: read    # Necessario per leggere gli artifact
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history per tag/version detection
        
    - name: Determine version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.version }}" ]; then
          # Versione manuale da input
          VERSION="${{ inputs.version }}"
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Versione da tag (rimuovi 'v' prefix)
          VERSION="${GITHUB_REF#refs/tags/v}"
        elif [ -f VERSION ]; then
          # Leggi da file VERSION
          VERSION=$(cat VERSION)
          # Incrementa patch version per ogni build
          COMMITS=$(git rev-list --count HEAD)
          BASE_VERSION=$(echo $VERSION | cut -d. -f1-2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          VERSION="${BASE_VERSION}.$((PATCH + COMMITS))"
        else
          # Versione automatica basata su commit count
          COMMITS=$(git rev-list --count HEAD)
          VERSION="0.0.${COMMITS}"
        fi
        
        # Rimuovi eventuali caratteri non validi
        VERSION=$(echo "$VERSION" | sed 's/[^0-9.]//g')
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Versione determinata: $VERSION"
        
    - name: Update version files
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Aggiorna file VERSION
        echo "$VERSION" > VERSION
        
        # Aggiorna backend/main.py
        sed -i "s/version=\"[^\"]*\"/version=\"$VERSION\"/" backend/main.py
        
        # Aggiorna frontend/package.json
        sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" frontend/package.json
        
        echo "‚úÖ Versioni aggiornate a $VERSION"
        cat VERSION
      
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y makeself || echo "makeself non disponibile nel repo, verr√† scaricato"
        
    - name: Check makeself availability
      id: check_makeself
      run: |
        if command -v makeself.sh &> /dev/null 2>&1; then
          echo "available=true" >> $GITHUB_OUTPUT
          echo "‚úì makeself.sh trovato in PATH"
          makeself.sh --version 2>/dev/null || true
        else
          echo "available=false" >> $GITHUB_OUTPUT
          echo "‚ö† makeself.sh non in PATH, verr√† scaricato"
        fi
        
    - name: Build installer_dsm.sh
      run: |
        # Il repository √® gi√† nella root del workspace
        # Simula la struttura: makeself-2.5.0/ con nas/ come sibling
        # Ma in GitHub Actions, il repo √® gi√† nella root, quindi:
        
        cd "$GITHUB_WORKSPACE"
        
        # Installa o usa makeself
        if [ "${{ steps.check_makeself.outputs.available }}" = "true" ] && command -v makeself.sh &> /dev/null 2>&1; then
          MAKESELF_CMD="makeself.sh"
          echo "‚úì Usando makeself.sh dal sistema"
        else
          # Fallback: scarica makeself via git (pi√π affidabile del .run)
          echo "üì• Scaricamento makeself dal repository GitHub..."
          cd /tmp
          rm -rf makeself-repo 2>/dev/null || true
          
          # Prova a clonare il repository makeself
          if command -v git &> /dev/null 2>&1; then
            git clone --depth 1 https://github.com/megastep/makeself.git makeself-repo 2>&1 || {
              echo "‚ö† Clone git fallito, provo con file .run..."
            }
            
            if [ -f "/tmp/makeself-repo/makeself.sh" ]; then
              MAKESELF_CMD="/tmp/makeself-repo/makeself.sh"
              chmod +x "$MAKESELF_CMD"
              cd "$GITHUB_WORKSPACE"
              echo "‚úì makeself trovato via git: $MAKESELF_CMD"
            fi
          fi
          
          # Se git non ha funzionato, usa il file .run
          if [ -z "$MAKESELF_CMD" ] || [ ! -f "$MAKESELF_CMD" ]; then
            echo "üì• Scaricamento makeself 2.5.0.run..."
            cd "$GITHUB_WORKSPACE"
            wget -q https://github.com/megastep/makeself/releases/download/release-2.5.0/makeself-2.5.0.run || {
              echo "‚ùå Errore nel download di makeself"
              exit 1
            }
            chmod +x makeself-2.5.0.run
            
            # Estrai makeself in directory temporanea
            EXTRACT_DIR="/tmp/makeself-extract"
            rm -rf "$EXTRACT_DIR" 2>/dev/null || true
            mkdir -p "$EXTRACT_DIR"
            cd "$EXTRACT_DIR"
            
            # Estrai il file (senza --target per estrarre nella directory corrente)
            bash "$GITHUB_WORKSPACE/makeself-2.5.0.run" --nox11 --quiet 2>&1 || {
              echo "‚ö† Estrazione senza target fallita, provo con --target..."
              bash "$GITHUB_WORKSPACE/makeself-2.5.0.run" --nox11 --quiet --target "$EXTRACT_DIR" 2>&1 || {
                echo "‚ùå Errore nell'estrazione di makeself"
                exit 1
              }
            }
            
            # Cerca makeself.sh - potrebbe essere in diverse posizioni
            MAKESELF_SCRIPT=""
            for possible_path in \
              "$EXTRACT_DIR/makeself-2.5.0/makeself.sh" \
              "$EXTRACT_DIR/makeself.sh" \
              "./makeself.sh" \
              "$(find "$EXTRACT_DIR" -name "makeself.sh" -type f 2>/dev/null | head -1)" \
              "$(find . -maxdepth 3 -name "makeself.sh" -type f 2>/dev/null | head -1)"; do
              if [ -n "$possible_path" ] && [ -f "$possible_path" ]; then
                MAKESELF_SCRIPT="$(cd "$(dirname "$possible_path")" && pwd)/$(basename "$possible_path")"
                [ -f "$MAKESELF_SCRIPT" ] && break || MAKESELF_SCRIPT=""
              fi
            done
            
            if [ -z "$MAKESELF_SCRIPT" ] || [ ! -f "$MAKESELF_SCRIPT" ]; then
              echo "‚ùå makeself.sh non trovato dopo l'estrazione"
              echo "Contenuto directory di estrazione ($EXTRACT_DIR):"
              ls -la "$EXTRACT_DIR" 2>/dev/null || true
              echo "Contenuto directory corrente:"
              ls -la . 2>/dev/null || true
              echo "Cerca tutti i file .sh:"
              find "$EXTRACT_DIR" -name "*.sh" -type f 2>/dev/null | head -10 || true
              find . -maxdepth 3 -name "*.sh" -type f 2>/dev/null | head -10 || true
              exit 1
            fi
            
            chmod +x "$MAKESELF_SCRIPT"
            MAKESELF_CMD="$MAKESELF_SCRIPT"
            cd "$GITHUB_WORKSPACE"
            echo "‚úì makeself trovato: $MAKESELF_CMD"
          fi
        fi
        
        # Leggi versione
        VERSION="${{ steps.version.outputs.version }}"
        INSTALLER_NAME="installer_dsm_v${VERSION}.sh"
        
        # Assicurati che tutti gli script siano eseguibili prima di creare l'archivio
        echo "Impostazione permessi di esecuzione per gli script..."
        find scripts/ -type f -name "*.sh" -exec chmod +x {} \;
        find backend/scripts/ -type f -name "*.py" -exec chmod +x {} \; 2>/dev/null || true
        chmod +x scripts/install.sh || true
        
        # Verifica che install.sh sia eseguibile
        if [ ! -x "scripts/install.sh" ]; then
          echo "‚ùå ERRORE: scripts/install.sh non √® eseguibile!"
          ls -la scripts/install.sh
          chmod +x scripts/install.sh
        fi
        
        echo "‚úì Permessi impostati"
        
        # Esegui makeself come nel tuo comando:
        # ./makeself.sh ../nas/ installer_dsm.sh VirtualDSM ./scripts/install.sh
        # Ma in GitHub Actions, il repo √® gi√† nella root, quindi usiamo ./
        echo "Esecuzione makeself per versione $VERSION..."
        $MAKESELF_CMD ./ "$INSTALLER_NAME" "VirtualDSM v${VERSION}" ./scripts/install.sh
        
        # Sposta il file risultante in scripts/
        if [ -f "$INSTALLER_NAME" ]; then
          mv "$INSTALLER_NAME" scripts/
          # Crea anche un symlink/alias senza versione per compatibilit√†
          cp "scripts/$INSTALLER_NAME" "scripts/installer_dsm.sh"
          echo "‚úì $INSTALLER_NAME creato in scripts/"
          echo "‚úì installer_dsm.sh (alias) creato in scripts/"
        else
          echo "‚úó ERRORE: $INSTALLER_NAME non creato!"
          exit 1
        fi
        
    - name: Verify installer file
      run: |
        if [ ! -f "scripts/installer_dsm.sh" ]; then
          echo "ERRORE: installer_dsm.sh non trovato!"
          exit 1
        fi
        
        # Verifica che sia un file makeself valido
        file scripts/installer_dsm.sh
        ls -lh scripts/installer_dsm.sh
        
        # Verifica che sia eseguibile
        chmod +x scripts/installer_dsm.sh
        
    - name: Test extraction (dry run)
      run: |
        # Test estrazione senza eseguire
        mkdir -p /tmp/test_extract
        cd /tmp/test_extract
        bash "$GITHUB_WORKSPACE/scripts/installer_dsm.sh" --help || bash "$GITHUB_WORKSPACE/scripts/installer_dsm.sh" --check || echo "File makeself valido"
        rm -rf /tmp/test_extract
        
    - name: Upload installer as artifact
      uses: actions/upload-artifact@v4
      with:
        name: installer-dsm-v${{ steps.version.outputs.version }}
        path: |
          scripts/installer_dsm_v${{ steps.version.outputs.version }}.sh
          scripts/installer_dsm.sh
        retention-days: 90
        
    - name: Create GitHub Release
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        files: |
          scripts/installer_dsm_v${{ steps.version.outputs.version }}.sh
        name: Release v${{ steps.version.outputs.version }}
        body: |
          ## VirtualDSM Installer v${{ steps.version.outputs.version }}
          
          ### Download
          - **installer_dsm_v${{ steps.version.outputs.version }}.sh** - Installer completo
          
          ### Installazione
          ```bash
          chmod +x installer_dsm_v${{ steps.version.outputs.version }}.sh
          sudo ./installer_dsm_v${{ steps.version.outputs.version }}.sh
          ```
          
          ### Build Info
          - **Versione:** ${{ steps.version.outputs.version }}
          - **Commit:** ${{ github.sha }}
          - **Data:** ${{ github.event.head_commit.timestamp }}
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Summary
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        echo "## üì¶ Installer Build Completato" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Versione:** \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**File creati:**" >> $GITHUB_STEP_SUMMARY
        echo "- \`installer_dsm_v${VERSION}.sh\`" >> $GITHUB_STEP_SUMMARY
        echo "- \`installer_dsm.sh\` (alias)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üì• Scarica l'artifact \`installer-dsm-v${VERSION}\` per ottenere i file." >> $GITHUB_STEP_SUMMARY

